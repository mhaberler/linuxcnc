= Requirements for the LinuxCNC Middleware

Michael Haberler, 11/2013

Status: draft

:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}
:proto: {basebackend@docbook:'':proto}

== Terminology

Middleware is the software layer that lies between
the operating system and applications on each side of a distributed
computing system in a network.

Message encoding encompasses the serialisation and deserialisation
operations. Serialisation is the process of translating data
structures or object state into a format that can be stored (for
example, in a file or memory buffer, or transmitted across a network
connection link) and resurrected later in the same or another computer
environment.

== Purpose

This document spells out the requirements for a middleware transport
and message encoding stack which is to replace NML/RCS as the message
transport stack in LinuxCNC.

== Scope

This document addresses all parts of LinuxCNC which are involved in
generation, interpretation and conveyance of messages and hence spans
all execution environments: normal user processes, userland and kernel
threads RT components, and the API's interfacing such
components.

== Common requirements

The following applies to both the transport stack as well as message encoding:

=== Language support

The middleware transport and encoding shall support in the minimum
C,C++ and Python language bindings.


=== Fitness for RT environment

The message stack and supporting code shall run on all supported
realtime kernels unchanged as part of a userland process.

It is explicitly not required for the message transport to support
execution within RT threads, as interworking with RT threads will
be supported by a ringbuffer API at the HAL level which can bridge
between userland and RT threads of either flavor, as well as between
RT threads.

It is, however, required that messages specified in any IDL language
can be interpreted and generated by code executed by RT threads of any flavor.

=== Transparent proxying of messaging

There shall be no requirement for intermediary
components to understand message contents beyond what is required by
the semantics of the involved component.

=== No arbitrary limitations

Both message transport as well as encoding shall not unduly constrain use, for instance by
setting hard limits on message sizes as currently mandated by NML/RCS.

== Message stack requirements

=== Blocking and non-blocking message reception

The transport stack shall support waiting for a message (optionally
with a timeout which may be zero) without resorting to busy waiting
(cyclically polling for a new message being present).

===  Startup order

The message transport should support any order of startup of producers
and consumers of messages.

=== Idempotent connect/reconnect

A component exiting and restarting shall be able to reconnect to a
running system without forcing a full shutdown and restart of the
realtime stack.

Note: this requirement suggests a property of the messaging stack per se. It
does not suggest all components should be coded such that arbitrary
exit and reconnect is possible under all circumstances.

It does, however, suggest the messaging stack shall support detection
of disconnect and reconnect such that a starting component may
synchronize state to the extent needed.

=== Broker-free architecture

The message transport should support operation without requiring a
broker process being present. Some message stacks rely on, and require
a broker to be present at all times.

===  Configuration requirements

The message transport shall be usable with no or minimal configuration
prerequisites. Support for optional autodetection of peers is desirable.

===  Authentication and encryption

Optional support for strong authentication and encryption is
desirable.


== Message Encoding requirements

=== IDL-based encoding

It should be possible to define message formats and have these
referenced in all supported languages and execution environments
without resorting to manual coding of message formats. This suggests
the usage of an IDL-based encoding method.

=== Message Introspection

Introspection refers to the capability of messages to divulge details
about themselves at runtime, and significantly eases writing code
which deals with new or unknown message formats. The encoding method
shall support introspection for all must-have language bindings.

=== Versioning support

The message encoding shall support versioning of message formats such
that backwards-compatible extensions of messages to not require
immediate recompilation and upgrade of all involved
components. Message extensions not understood by older components
shall be skipped uninterpreted.


=== Architecture independence

The message encoding method shall assure architectural differences of
participating hosts (byte order, floating point representation etc) do
not affect interoperation and are taken care of automatically.


=== Automatic "web-friendly" encoding

It should be possible to transmit messages from and to web-based UI's
without manually transcoding messages in intermediary components. An
example could be a Javascript-based UI exchanging JSON objects via a
Websockets transport.

This requirement would typically be fulfilled by using a message
encoding method capable of introspection.
