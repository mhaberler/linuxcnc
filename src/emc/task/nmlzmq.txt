
= Migrating NML to a ZeroMQ transport

:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}

== Making NML disappear: the steps needed

To get rid of NML, we need to replace two functions of the NML/RCS
stack:

- the transport function (shared memory and TCP)
- the message serialisation/deserialisation function

It has turned out that replacing the transport first, and
serialisation second is a preferrable route as it allows coexistence
and regression testing.

We also need to replace the interaction patterns currently in use:


=== Replacing the NML/RCS transport: the interaction patterns

The basic functions currently in use are:

. command submission
. waiting for reception acknowledgement OR:
. optionally waiting for command execution completion
. status observation: basically peeking at the EMC_STAT structure.
. error message distribution

4 and 5 can be easily mapped onto the ZMQ PUB/SUB pattern, 1-3
are a bit more involved:

=== ZeroMQ flows in the task/gui interactions

There will be no client-side serial numbers. The will be a single
global ticket number managed by task.

The basic idea of command submission with optionally waiting for
completion is this:

- clients have a name, and that is used as a ZMQ socket identity as
  well as SUBSCRIBE channel name
- submission always happens through an RPC mechanism, so the
  'WaitReceived()' is implicit
- command numbering - now called tickets - happens globally in task,
  and are distributed to clients in the RPC reply
- waiting for completion (optional) happens by listening for
  completion updates in a separate PUBLISH channel fed by task. The
  channel name mechanism is used to direct completion updates to their
  respective originators (aka 'client').


==== Server setup - task:

- task creates a PUB socket with a low high water mark (for sending status updates
  on command completion)
- task creates an ROUTER socket (command submission listener)
- task maintains a global uniqe serial, which is the command ticket
  number.
- task listens on ROUTER socket.

==== client setup - shmcom.cc, emcmodule.cc etc:

- client creates an unique identity string, eg composed of name, pid and IP
  address
- client creates a DEALER socket for command transmission
- client sets the DEALER socket identity to the above unique string
- client creates a SUB socket, sets identity to the above unique string
- client binds to the server PUB socket, subscribing for for 'command
  complete' updates

==== command submission phase:

- client prepares command message, and submits it to the DEALER socket
- task receives request, pulls a new ticket number, packs it into
  reply
- task records client identity from socket identity string (see
  'client setup')
- client receives reply from task, now has a command ticket number:
  this is the semantic equivalent of emcCommandWaitReceived() in shcom.cc .
- task records the originator of each command.

==== command execution and completion phase (task)

Once the command is processed, there is a status - success or some
failure detail (RCS_DONE/RCS_ERROR).

On completion, task

- determines the originator of the command (socket identity - must be
  cached in task)
- creates a status update message with success/error report
- pushes this update into the PUB channel with the originator identity
  as a channel attribute.

==== command execution and completion phase (client)

if the client desires to wait for command completion (equivalent of
shcom.cc:emcCommandWaitDone()):

- after receiving the initial reply from task (see command submission
  phase) the client loops on the SUB socket, receiving command
  completion messages, with a timeout.

-  due to the channel name used for pushing the update by task, which is
  identically to the client identity, there will only be
  updates for commands originated by this client coming through this
  channel.

- the client compares the completion message ticket number with the
  ticket number passed in the initial reply. As soon as this ticket
  number is seen in the update, this indicates command completion as
  in emcCommandWaitDone().

==== completion updates a client isnt interested in

Due to the high water mark mechanism in the PUB socket, unread updates
are eventually discarded. If there are queued updates for previous
commands which the client wasnt interested in, but now is interested
in the completion status of a particular command, the ticket number,
and total ordering of ticket number, enables the client to skip
completion updates which are for previous commands.


=== EMC_STAT members access in task
readhead.cc:
	    emcStatus->task.execState
	    emcStatus->task.interpState
	    emcStatus->task.readLine
	    emcStatus->motion.traj.queue // test for MDI finished
	    emcStatus->io.status // test for MDI finished

emccanon.cc:
   setup?
	emcStatus->motion.traj.axis_mask (axisvalid)
	emcStatus->task.programUnits
	emcStatus->motion.traj.linearUnits;
	emcStatus->motion.traj.angularUnits;
	emcStatus->motion.traj.axis_mask;

   dynamic:
	emcStatus->io.tool.toolTable
	emcStatus->io.tool.toolInSpindle;
	emcStatus->io.tool.pocketPrepped;
	emcStatus->io.fault;
	emcStatus->io.reason;

	EmcPose emcStatus->motion.traj.position; //GET_EXTERNAL_POSITION()
	emcStatus->motion.traj.probedPosition;
	emcStatus->motion.traj.probe_tripped;
	emcStatus->motion.traj.maxVelocity
	emcStatus->io.coolant.mist;
	emcStatus->io.coolant.flood;
	emcStatus->motion.spindle.speed
	emcStatus->motion.traj.queue
	emcStatus->motion.traj.feed_override_enabled;
	emcStatus->motion.traj.spindle_override_enabled;
	emcStatus->motion.traj.adaptive_feed_enabled;
	emcStatus->motion.traj.feed_hold_enabled
	emcStatus->task.input_timeout
	emcStatus->motion.synch_di[index]
	emcStatus->motion.analog_input

emctask.cc:
	emcStatus->task.interpState = EMC_TASK_INTERP_IDLE;
	 emcStatus->task.execState = EMC_TASK_EXEC_DONE;
	 emcStatus->task.task_paused = 0;
	 emcStatus->task.motionLine = 0;
	 emcStatus->task.readLine = 0;
	 emcStatus->task.command[0] = 0;
	 emcStatus->task.interpreter_errcode
	 emcStatus->task.file[0]

	 emcStatus->motion.traj.axes;
	 emcStatus->motion.traj.mode == EMC_TRAJ_MODE_FREE
	 emcStatus->io.aux.estop
	 emcStatus->motion.traj.enabled
	 emcStatus->motion.traj.inpos;
	 emcStatus->motion.traj.id

issue.cc:
	emcStatus->motion.traj.axis_mask
	emcStatus->task.task_paused

nmlsetup.cc: init, initial read only


readahead.cc:
	emcStatus->task.execState
	emcStatus->task.interpState
	emcStatus->task.readLine

	emcStatus->motion.traj.queue
	emcStatus->io.status

taskintf,cc:  check for NULL only

taskmodule.cc: the full monty  (Python exposure)

=== Task total needs from motion  & io status:

emcStatus->io.aux.estop
emcStatus->io.coolant.flood;
emcStatus->io.coolant.mist;
emcStatus->io.fault;
emcStatus->io.reason;
emcStatus->io.status
emcStatus->io.tool.pocketPrepped;
emcStatus->io.tool.toolInSpindle;

emcStatus->io.tool.toolTable       *

----------- emcMotionUpdate() ----------
emcStatus->motion.analog_input
emcStatus->motion.spindle.speed
emcStatus->motion.synch_di[index]   *
emcStatus->motion.synch_ai[index]   *
emcStatus->motion.traj.adaptive_feed_enabled;
emcStatus->motion.traj.angularUnits;
emcStatus->motion.traj.axes;
emcStatus->motion.traj.axis_mask;
emcStatus->motion.traj.enabled
emcStatus->motion.traj.feed_hold_enabled
emcStatus->motion.traj.feed_override_enabled;
emcStatus->motion.traj.id
emcStatus->motion.traj.inpos;
emcStatus->motion.traj.linearUnits;
emcStatus->motion.traj.maxVelocity
emcStatus->motion.traj.mode
emcStatus->motion.traj.position    *Pose
emcStatus->motion.traj.probe_tripped;
emcStatus->motion.traj.probedPosition;  *Pose
emcStatus->motion.traj.queue
emcStatus->motion.traj.spindle_override_enabled;
emcStatus->motion.analog_input[aio];
emcStatus->motion.analog_output[aio];

==== Axis data ====

per Axis: 12 doubles, 11 flags

    unsigned char axisType;	// EMC_AXIS_LINEAR, EMC_AXIS_ANGULAR

    double units;		// units per mm, deg for linear, angular
    double backlash;
    double minPositionLimit;
    double maxPositionLimit;
    double maxFerror;
    double minFerror;

    // dynamic status
    double ferrorCurrent;	// current following error
    double ferrorHighMark;	// magnitude of max following error
    /*! \todo FIXME - is this really position, or the DAC output? */
    double output;		// commanded output position
    double input;		// current input position
    double velocity;		// current velocity


    unsigned char inpos;	// non-zero means in position
    unsigned char homing;	// non-zero means homing
    unsigned char homed;	// non-zero means has been homed
    unsigned char fault;	// non-zero means axis amp fault
    unsigned char enabled;	// non-zero means enabled
    unsigned char minSoftLimit;	// non-zero means min soft limit exceeded
    unsigned char maxSoftLimit;	// non-zero means max soft limit exceeded
    unsigned char minHardLimit;	// non-zero means min hard limit exceeded
    unsigned char maxHardLimit;	// non-zero means max hard limit exceeded
    unsigned char overrideLimits; // non-zero means limits are overridden

=== Correlating commands and status

TBD: reverse-engineer what might have been the intended semantics of
current broken serial number mechanism.

=== Evaluation of results - current work-in-progress branch

The following comments apply to
https://github.com/mhaberler/linuxcnc/tree/zmq-submit-task-commands as
per commit 19a8fd:

. The setup and flows as laid out above do work, no discernible
difference in performance. Since the number of task/UI interactions
overall in a program run is very low, it'd be hard to tell either.

. There is currently no protection against initial miss of messages
over the PUB/SUB socket pair. (search for 'the subscriber will always miss the first messages that
the publisher sends' in 'http://zguide.zeromq.org/page:all' for an
explanation). This does not trigger in the current setup, and unlikely
will, but a bulletproof measure to avoid the scenario would be
valuable.

. Update queue constipation by clients which never wait for a command
completion ticket update: right now, task keeps publishing update
tickets even if a subscriber is present and subscribed, but only
rarely actually watches the subscribe socket and pulls completion
updates (note ZMQ semantics assures this happens only if a subscriber
is present; publish messages and no subscriber listening are dropped
at the publisher side). What would happen if this goes for long stretches: The
outgoing per-subscriber queue in the pub socket will overflow, and
subsequent messages will not be added. This could lead to a deadlock
situation where a client waits forever for an update which has been
dropped to to queue overrun.

==== Improvements to deal with these issues

To close the first vulnerability:

- we introduce a NOOP task command which will cause a normal ticket
assignment and state update on the PUB channel on 'completion'.
- at startup time, the client issues a (or a few up to a maximum) NOOP
commands and retries until completion updates are received and match
the request ticket number.
- as a bonus, we get a liveness test of the task/UI interaction on
startup.

To deal with the second issue:

. A client establishes a listener thread on the SUB socket, fetching
ticket updates immediately as they come in. This thread atomically updates the
highest ticket number seen and the corresponding status.

. the main thread atomically reads the highest ticket number, and
waits (up to a timeout maximum) if the currently issue ticket number
isnt seen in the update stream with status RCS_DONE or RCS_ERROR yet.

A side effect of fetching of updates in a separate thread is higher parallelism
resulting in a a faster acknowledgement since the main thread doesnt
have to read through the series of queued updates until the current
ticket number and state is found;  during test runs, up to maybe 15
queued updates have been seen.

===== An alternate solution to the second issue:

There is currently a feature under discussion tentatively named
'ZMQ_FLAT_PULL' (see ZMQ developers mailing list of Jun 7 2013) which
would deal with the queue obstipation issue by
dropping older messages in case of contention (only the last
message counts since the previous tickets are implicitly
completed). The current behavior is to retain old messages and deny
queue adds if the high water mark is reached.

This would match closely the previous semantics of overwrites
of a shared buffer in the NML transport.

Downside: the feature isnt published yet, and also it is planned for
ROUTER sockets; we'd prefer to have that behavior in a PUB socket.

=== Building the work-in-progress branch

This branch brings in Google Protobuf support, including message
formats geared for LinuxCNC, to be found in `src/protobuf/proto`. All
messages are translated into libraries and Python modules as follows:

. C++ - using the stock Google Protobuf code, resulting in the
`lib/liblinuxcncp-b2++.so.0` library

. Python, also using stock Google Protobuf, resulting in modules in
lib/python

. C - using the C bindings package from
http://code.google.com/p/protobuf-c/, resulting in the
`lib/liblinuxcncp-b2.so.0` library

. NanonPB C bindings - a C binding originally developed for embedded
systems: http://koti.kapsi.fi/jpa/nanopb/ - this code is a bit more
involved in use than the other C and C++ bindings, but the key
advantage is that it can work in realtime code (kernel and userland)
since it does not rely on dynamic memory allocation; resulting in
`lib/liblinuxcnc-npb.so.0` (userland use) .

==== Installing the package prerequisites on wheezy

All packages except one (czmq) can be fetched from the wheezy or
jessie archives. Proceed like so:

I assume we'll use stable by default, so edit:

  sudo vi /etc/apt/apt.conf

and add

  APT::Default-Release "stable";

Next, add the jessie reference to /etc/apt/sources.list . Mine looks
like so:

 deb http://ftp.de.debian.org/debian/ wheezy main contrib non-free
 deb-src http://ftp.de.debian.org/debian/ wheezy main contrib non-free

 deb http://ftp.de.debian.org/debian/ jessie main contrib non-free
 deb-src http://ftp.de.debian.org/debian/ jessie main contrib non-free

 deb http://ftp.de.debian.org/debian/ wheezy-updates main contrib non-free
 deb-src http://ftp.de.debian.org/debian/ wheezy-updates main contrib non-free

 deb http://security.debian.org/ wheezy/updates main contrib non-free
 deb-src http://security.debian.org/ wheezy/updates main contrib non-free

Now do:

 apt-get update
 apt-get install libprotobuf-dev libprotoc-dev protobuf-compiler \
 python-protobuf  libprotobuf-c0-dev protobuf-c-compiler \
 fakeroot dpkg-dev libpgm-dev python-setuptools

We need these packages from jessie/testing as the wheezy ones are too old:

 apt-get install -t testing libzmq3-dev libjansson-dev

The Pyzmq bindings are installed like so:

 sudo easy_install pyzmq

The only non-stock package is czmq, build like so:

 git clone https://github.com/ellysh/czmq
 cd czmq
 dpkg-buildpackage -rfakeroot -b  -us -uc
 cd ..
 sudo dpkg -i libczmq*.deb

Done! just 22 or so easy steps ;-)


==== Building the work branch

After the 22 or so above steps, you can now build the work branch..

This requires the following configure options:

Choose a flavor support by your os, like 'rtai-kernel', 'xenomai',
'rt-preempt', or 'posix' (formerly 'simulator'), then:

 cd src
 sh autogen.sh
 ./configure --with-<flavor> --enable-protobuf --enable-zeromq --enable-examples
 make
 sudo make setuid
 . ../scripts/rip-environment

==== Running the work branch

Open a window and run the update listener Python program:

  cd linuxcnc
  . scripts/rip-environment
  cd src/emc/task
  python statustrack.py

Now start linuxcnc like so in another window, enable ZMQ command
 submission and debug output of message transactions:

 cd linuxcnc
 . scripts/rip-environment
 USE_ZMQ=1 ZDEBUG=1 linuxcnc

Choose for instance sim/axis/axis_mm.ini. Note the ticket updates in
the statustrack.py window, and the protobuf messages going back and
forth.

=== Building all support packages from source

(NOT recommended, for reference only)


==== Building the protobuf support code

The following packages are needed in sufficiently recent form:

. `libprotobuf-dev` - protocol buffers C++ library (development headers)
. `libprotobuf5` - protocol buffers C++ library
. `libprotoc-dev - protocol buffers compiler library (development headers)
. `protobuf-compiler` - compiler for protocol buffer definition files
. `python-protobuf` - Python bindings for protocol buffers
. `libprotobuf-c0` - Protocol Buffers C library
. `libprotobuf-c0-dev` - Protocol Buffers C static library and headers
. `protobuf-c-compiler` - protocol buffers C compiler
. `libjansson-dev` - JSON C bindings for protobuf/JSON conversion

Nanopb has no package, but it's rather small and hence fully included
in `src/protobuf/nanopb`.

*I did not use those* - I do use protobuf and protobuf-c bindings
compiled from the current development branches. This is the
recommended method:

==== Building the Google C++ protobuf support code

This will install into /usr/local :

 sudo apt-get install subversion
 svn checkout http://protobuf.googlecode.com/svn/trunk/ protobuf-read-only
 cd  protobuf-read-only

 ./configure
 make
 make check
 make install

==== Building the Google Python protobuf support code

The previous step must be completed before this:

 cd python
 python setup.py build
 python setup.py test
 python setup.py install

==== Building the protobuf C support code

See also: http://code.google.com/p/protobuf-c/wiki/Main_Page . For
installation in /usr/local use:

   svn checkout http://protobuf-c.googlecode.com/svn/trunk/ protobuf-c-read-only
   cd protobuf-c-read-only
   ./configure
   make
   sudo make install

==== Building the zeromq support code

===== Building libzmq

This is the core support library. Proceed as follows to install in
`/usr/local`:

 git clone https://github.com/zeromq/libzmq.git
 cd libzmq
 ./configure
 make
 sudo make install

===== Building czmq

This is a higher-level C bindings library, used as API for C and
C++. The build needs libzmq installed as above, then proceed:

 git clone https://github.com/zeromq/czmq.git
 cd czmq
 ./configure
 make
 sudo make install

===== Building the Pyzmq Python ZMQ bindings

See https://github.com/zeromq/pyzmq/wiki/Building-and-Installing-PyZMQ

To build pyzmq from the git repo requires Cython:

   sudo apt-get install cython

The Python bindings to ZMQ are built as follows:

 git clone git://github.com/zeromq/pyzmq.git
 cd pyzmq
 python setup.py configure --zmq=/usr/local
 sudo python setup.py install
