#
#  Protobuf support for LinuxCNC
#
#  build Python modules, C and C++ bindings from .proto files
#  build nanopb C bindings for kernel & userland RT components (and possibly embedded devices)
#
# to add a new message type:
#     1. create a .proto file under machinetalk/proto
#     2. add the message type to machinetalk/proto/types.proto
#        enum MessageType, e.g. MT_EMC_OPERATOR_TEXT_TYPE
#     3. if the message will be used in-kernel/RT components, consider using
#        machinetalk/nanopb.options to use fixed-size arrays for strings and
#        repeated fields
#     4. refer to the message type by including
#        machinetalk/generated/types.pb-c.h and use e.g.
#        MESSAGE_TYPE_MT_EMC_OPERATOR_TEXT_TYPE
#
# TODO:
#    generate compiled Python bindings for better performance, current options
#    (sorted in decreasing order of estimated stability/completeness at this time):
#
#    1: either use the PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION feature of
#    google protobuf distro, or
#    2. use http://evgenus.github.com/protocyt/ Cython-based bindings
#    3: use https://github.com/Cue/fast-python-pb
#
# Michael Haberler 2/2013


MWDIR=machinetalk
PBGEN=$(MWDIR)/generated
PROTODIR=$(MWDIR)/proto/proto
NANOPB := $(MWDIR)/nanopb
NPBPROTODIR :=  $(NANOPB)/generator/proto

# the directory where descriptor.proto lives:
GPBINCLUDE :=  $(shell pkg-config --variable=includedir protobuf)
DESCDIR    :=  $(GPBINCLUDE)/google/protobuf

# search path for .proto files
# see note on PBDEP_OPT below
vpath %.proto  $(PROTODIR):$(NPBPROTODIR):$(GPBINCLUDE):$(DESCDIR)/compiler

# the set of all proto specs generated files depend on
PROTO_SPECS := $(wildcard $(PROTODIR)/*.proto)

USERSRCS += $(PROTO_SPECS)

# C bindings library
PROTOCLIB = ../lib/liblinuxcnc-pb2.so

# C++ bindings library
PROTOCXXLIB = ../lib/liblinuxcnc-pb2++.so

# Nanopb C bindings library
NANOPROTOCLIB := ../lib/liblinuxcnc-npb.so
PROTOC := $(shell which protoc)
PROTOC_C := $(shell which protoc-c)
PROTOC_FLAGS :=
PROTOC_C_FLAGS := -fPIC
PROTOC_C_LDFLAGS := -lprotobuf-c
PROTOCXX_LDFLAGS := $(PROTOBUF_LIBS) 
PROTOCXX_FLAGS :=
PROTOCXX_CXX_FLAGS := -fPIC $(PROTOBUF_CFLAGS)

# tell protobuf to use compiled C for Python bindings
# not available in 2.4.1/jessie
#export PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=cpp

# NANOPB_CFLAGS are also passed to module build through
# RTFLAGS - see hal/msgcomponents/Submakefile
NANOPB_CFLAGS := -DPB_FIELD_32BIT '-DPB_SYSTEM_HEADER=<'$(MWDIR)'/include/pb-linuxcnc.h>'
NANOPB_OPTIONS := $(MWDIR)/nanopb.options

# any extra flags to C compile nanopb bindings
PROTO_NANOPB_CFLAGS := $(NANOPB_CFLAGS) #-fPIC

# nanopb library .h/.c files
NANOPB_INCS := $(wildcard $(NANOPB)/*.h)
NANOPB_C_SRCS := $(wildcard $(NANOPB)/*.c)

# headers which are to go into ../include
NANOPB_INSTALL_INCS := $(subst $(NANOPB), \
	../include/$(NANOPB),  \
	$(NANOPB_INCS))

PROTO_NANOPB_C_INCS := $(subst $(PROTODIR)/, \
	$(PBGEN)/,  \
	$(patsubst %.proto, %.npb.h, $(PROTO_SPECS)))

PROTO_NANOPB_C_SRCS := $(subst $(PROTODIR)/, \
	$(PBGEN)/,  \
	$(patsubst %.proto, %.npb.c, $(PROTO_SPECS)))

# Nanopb generator support
NANOPB_SUPPORT := ../lib/python/nanopb_pb2.py
NANOPB_SUPPORT += ../lib/python/google/protobuf/compiler/plugin_pb2.py
NANOPB_SUPPORT += ../lib/python/google/protobuf/descriptor_pb2.py
NANOPB_SUPPORT += ../lib/python/nanopb_generator.py
NANOPB_SUPPORT += ../lib/python/protoc-gen-nanopb

PROTO_PY_TARGETS := $(NANOPB_SUPPORT)

# machinetalk/proto/*.proto derived Python bindings
PROTO_PY_TARGETS += $(subst $(PROTODIR)/, \
	../lib/python/, \
	$(patsubst %.proto, %_pb2.py, $(PROTO_SPECS)))

ifeq ($(BUILD_PROTOC_C),yes)

# generated C includes
PROTO_C_INCS := $(PBGEN)/nanopb.pb-c.h
PROTO_C_INCS += $(PBGEN)/google/protobuf/descriptor.pb-c.h
PROTO_C_INCS += $(subst $(PROTODIR)/, \
	$(PBGEN)/,  \
	$(patsubst %.proto, %.pb-c.h, $(PROTO_SPECS)))

# generated C sources
PROTO_C_SRCS := $(PBGEN)/nanopb.pb-c.c
PROTO_C_SRCS += $(PBGEN)/google/protobuf/descriptor.pb-c.c
PROTO_C_SRCS +=  $(subst $(PROTODIR)/, \
	$(PBGEN)/, \
	$(patsubst %.proto, %.pb-c.c, $(PROTO_SPECS)))
else
PROTO_C_INCS :=
PROTO_C_SRCS :=
endif

# generated C++ includes
PROTO_CXX_INCS :=  $(PBGEN)/nanopb.pb.h
PROTO_CXX_INCS += $(subst $(PROTODIR)/, \
	$(PBGEN)/,  \
	$(patsubst %.proto, %.pb.h, $(PROTO_SPECS)))

# generated C++ sources
PROTO_CXX_SRCS  :=  $(PBGEN)/nanopb.pb.cc
PROTO_CXX_SRCS  +=  $(subst $(PROTODIR)/, \
	$(PBGEN)/, \
	$(patsubst %.proto, %.pb.cc, $(PROTO_SPECS)))

# headers which are to go into ../include
INSTALL_INCS := $(subst $(PBGEN), \
	../include/$(PBGEN),  \
	$(PROTO_CXX_INCS) $(PROTO_C_INCS) $(PROTO_NANOPB_C_INCS))

INSTALL_INCS += \
	../include/machinetalk/include/pb-linuxcnc.h \
	../include/machinetalk/include/container.h \
	../include/machinetalk/json2pb/json2pb.hh \
	../include/machinetalk/json2pb/bin2ascii.hh \
	../include/machinetalk/nanopb/pb.h \
	../include/machinetalk/nanopb/pb_encode.h \
	../include/machinetalk/nanopb/pb_decode.h

# generate emctypes.proto from emc/nml_intf/emc.hh
$(PBGEN)/emctypes.proto: emc/nml_intf/emc.hh $(MWDIR)/scripts/extract-nmltypes
	$(ECHO) "extracting protobuf message types for NML from" $<
	@mkdir -p $(PBGEN)
	$(Q)$(MWDIR)/scripts/extract-nmltypes $< >$@

# generate mottypes.proto from emc/motion/motion.h
$(PBGEN)/mottypes.proto: emc/motion/motion.h $(MWDIR)/scripts/extract-mottypes
	$(ECHO) "extracting protobuf message types for Motion from" $<
	@mkdir -p $(PBGEN)
	$(Q)$(MWDIR)/scripts/extract-mottypes $< >$@

TARGETS += $(PBGEN)/emctypes.proto $(PBGEN)/mottypes.proto


# ---- generate dependcy files for .proto files
#
# the list of .d dep files for .proto files:
PROTO_DEPS :=  $(patsubst %,objects/%,$(patsubst %.proto,%.d,$(PROTO_SPECS)))
#
# options to the dependency generator protoc plugin
PBDEP_OPT :=
#PBDEP_OPT += --debug
PBDEP_OPT += --cgen=$(MWDIR)/generated
PBDEP_OPT += --pygen=lib/python
# this path must match the vpath arrangement exactly or the deps will be wrong
# unfortunately there is no way to extract the proto path in the code
# generator plugin
PBDEP_OPT += --vpath=$(PROTODIR)
PBDEP_OPT += --vpath=$(NPBPROTODIR)
PBDEP_OPT += --vpath=$(GPBINCLUDE)
PBDEP_OPT += --vpath=$(DESCDIR)/compiler

objects/$(PROTODIR)/%.d: $(PROTODIR)/%.proto
	$(ECHO) "protoc create dependencies for $<"
	@mkdir -p objects/$(PROTODIR)/
	$(Q)$(PROTOC) \
	--plugin=protoc-gen-depends=../scripts/protoc-gen-depends \
	--proto_path=$(PROTODIR)/ \
	--proto_path=$(NPBPROTODIR)/ \
	--proto_path=$(GPBINCLUDE) \
	--depends_out="$(PBDEP_OPT)":objects/$(PROTODIR) \
	 $<

# ------- protoc-c C rules -------------
#
# generate .c/.h from proto files
$(PBGEN)/%.pb-c.c $(PBGEN)/%.pb-c.h: %.proto
	$(ECHO) "protoc-c create $@ from $<"
	@mkdir -p $(PBGEN)
	$(Q)$(PROTOC_C) $(PROTOC_FLAGS) \
	--proto_path=$(PROTODIR)/ \
	--proto_path=$(NPBPROTODIR)/ \
	--proto_path=$(GPBINCLUDE) \
	--c_out=./$(PBGEN)/ $<

#---------- C++ rules -----------
#
# generate .cc/.h from proto files
# for command.proto, generated files are: command.pb.cc	command.pb.h
$(PBGEN)/%.pb.cc $(PBGEN)/%.pb.h: %.proto
	$(ECHO) "protoc create $@ from $<"
	@mkdir -p $(PBGEN)
	$(Q)$(PROTOC) $(PROTOCXX_FLAGS) \
	--proto_path=$(PROTODIR)/ \
	--proto_path=$(NPBPROTODIR)/ \
	--proto_path=$(GPBINCLUDE)/ \
	--cpp_out=./$(PBGEN)/ $<

# ----------- Nanopb c/h rules
#
# Nanopb: generate *.npb.{c,h} from proto files
# these depend on npb options
$(PBGEN)/%.npb.c $(PBGEN)/%.npb.h: %.proto $(NANOPB_SUPPORT)
	$(ECHO) "protoc create $@ from $<"
	@mkdir -p $(PBGEN)
	$(Q)$(PROTOC) $(PROTOC_FLAGS) \
	--plugin=protoc-gen-nanopb=../lib/python/protoc-gen-nanopb \
	--nanopb_out="--generated-include-format='#include <"$(PBGEN)"/%s>' --extension=npb --options-file=$(MWDIR)/nanopb.options":$(PBGEN) \
	--proto_path=$(PROTODIR)/ \
	--proto_path=$(GPBINCLUDE) \
	--proto_path=${NPBPROTODIR} \
	$<

# ------------- Python rules ------------
#
# this is for the stock protobuf Python bindings -
# adapt here if using one of the accelerated methods
#
# generate Python modules from proto files
../lib/python/%_pb2.py: %.proto
	$(ECHO) "protoc create $@ from $<"
	@mkdir -p ../lib/python
	$(Q)$(PROTOC) $(PROTOC_FLAGS) \
	--proto_path=$(PROTODIR)/ \
	--proto_path=$(NPBPROTODIR)/ \
	--proto_path=$(GPBINCLUDE)/ \
	--python_out=../lib/python/ $<

# --- misc supporting files ----
../lib/python/nanopb_generator.py: $(NANOPB)/generator/nanopb_generator.py
	cp $^ $@

../lib/python/proto/__init__.py:
	@mkdir -p ../lib/python/proto
	touch ../lib/python/proto/__init__.py

# the nanopb plugin executable
../lib/python/protoc-gen-nanopb: $(NANOPB)/generator/protoc-gen-nanopb
	cp $^ $@
	chmod 755 $@

# ---------- libraries ---------
#
# Nanopb C bindings library
#
NANOPB_LIBSRCS = $(NANOPB_C_SRCS) $(PROTO_NANOPB_C_SRCS)
$(call TOOBJSDEPS, $(NANOPB_LIBSRCS)) : EXTRAFLAGS += $(PROTO_NANOPB_CFLAGS)

$(NANOPROTOCLIB).0: $(patsubst %.c,objects/%.o,$(NANOPB_LIBSRCS))
	$(ECHO) Linking $(notdir $@)
	@mkdir -p ../lib
	@rm -f $@
	$(Q)$(CC) $(LDFLAGS) -Wl,-soname,$(notdir $@) -shared -o $@ $^

# C bindings library
$(call TOOBJSDEPS, $(PROTO_C_SRCS)) : EXTRAFLAGS += $(PROTOC_C_FLAGS)

$(PROTOCLIB).0: $(patsubst %.c,objects/%.o,$(PROTO_C_SRCS))
	$(ECHO) Linking $(notdir $@)
	@mkdir -p ../lib
	@rm -f $@
	$(Q)$(CC) $(LDFLAGS) -Wl,-soname,$(notdir $@) -shared -o $@ $^ \
	$(PROTOC_C_LDFLAGS)

# C++ bindings library
$(call TOOBJSDEPS, $(PROTO_CXX_SRCS)) : EXTRAFLAGS += $(PROTOCXX_CXX_FLAGS)

$(PROTOCXXLIB).0: $(patsubst %.cc,objects/%.o,$(PROTO_CXX_SRCS))
	$(ECHO) Linking $(notdir $@)
	@mkdir -p ../lib
	@rm -f $@
	$(Q)$(CXX) $(LDFLAGS) -Wl,-soname,$(notdir $@) -shared -o $@ $^

# pb2json translation library
PB2JSONLIB := ../lib/libjson2pb.so
PB2JSON = $(MWDIR)/json2pb
PB2JSONLIB_SRCS = $(PB2JSON)/json2pb.cc
PB2JSONLIB_CCXFLAGS :=  -g -O3 -shared -Wall -fPIC  $(PROTOBUF_CFLAGS)
PB2JSONLIB_LDFLAGS := $(PROTOCXXLIB) -ljansson 

$(call TOOBJSDEPS, $(PB2JSONLIB_SRCS)) : EXTRAFLAGS += $(PB2JSONLIB_CCXFLAGS)

$(PB2JSONLIB).0: $(call TOOBJS, $(PB2JSONLIB_SRCS))  $(PROTOCXXLIB)
	$(ECHO) Linking $(notdir $@)
	@mkdir -p ../lib
	@rm -f $@
	$(Q)$(CXX)  -Wl,-soname,$(notdir $@) -shared -o $@ $^ $(PB2JSONLIB_LDFLAGS)

# pb2json headers
../include/%.hh: ./$(PB2JSON)/%.hh
	@mkdir -p $(dir $@)
	cp $^ $@

# protoc/protoc-c generated headers are exported to ../include
../include/%.h: ./$(PBGEN)/%.h
	@mkdir -p $(dir $@)
	cp $^ $@

../include/%.hh: ./$(PBGEN)/%.hh
	@mkdir -p $(dir $@)
	cp $^ $@

# as are the nanop library headers
../include/%.h: ./$(NANOPB)/%.h
	@mkdir -p $(dir $@)
	cp $^ $@

../include/%.h: ./$(MWDIR)/%.h
	cp $^ $@

../include/%.h: ./$(MWDIR)/include/%.h
	@mkdir -p $(dir $@)
	cp $^ $@

# those will be compiled
USERSRCS +=  $(NANOPB_C_SRCS) \
	$(PROTO_CXX_SRCS) \
	$(PROTO_NANOPB_C_SRCS) \
	$(PB2JSONLIB_SRCS)

ifeq ($(BUILD_PROTOC_C),yes)

USERSRCS += $(PROTO_C_SRCS) \
	$(MWDIR)/generated/descriptor.pb-c.h \
	$(MWDIR)/generated/descriptor.pb-c.c
endif

GENERATED += $(PROTO_PY_TARGETS) \
	$(MWDIR)/generated/nanopb.pb.h	\
	$(MWDIR)/generated/nanopb.pb.cc \
	$(PROTO_CXX_SRCS) $(PROTO_NANOPB_C_SRCS) \
	$(PROTO_CXX_INCS) $(PROTO_NANOPB_C_INCS)

ifeq ($(BUILD_PROTOC_C),yes)
GENERATED += \
	$(PROTO_C_SRCS) $(PROTO_CXX_SRCS) $(PROTO_NANOPB_C_SRCS) \
	$(PROTO_C_INCS) $(PROTO_CXX_INCS) $(PROTO_NANOPB_C_INCS) \
	$(MWDIR)/generated/nanopb.pb-c.h  \
	$(MWDIR)/generated/nanopb.pb-c.c
endif

PYTARGETS += $(PROTO_PY_TARGETS)

INCLUDES += $(PBGEN)
INCLUDES += $(NANOPB)
INCLUDES += $(PB2JSON)

TARGETS += $(PROTO_CXX_INCS) $(PROTO_C_INCS) $(PROTO_NANOPB_C_INCS)
TARGETS += $(INSTALL_INCS)
TARGETS += $(NANOPROTOCLIB) $(NANOPROTOCLIB).0 \
	$(PROTOCXXLIB) $(PROTOCXXLIB).0 \
	$(PB2JSONLIB) $(PB2JSONLIB).0

ifeq ($(BUILD_PROTOC_C),yes)
TARGETS += $(PROTOCLIB) $(PROTOCLIB).0
endif

