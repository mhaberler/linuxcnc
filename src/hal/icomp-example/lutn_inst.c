/* Autogenerated by /usr/src/machinekit-icomp3-working-copy/bin/instcomp on Sat Mar 21 16:29:18 2015 -- do not edit */

#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "hal_priv.h"

static int comp_id;

static char *compname = "lutn_inst";

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:lutn_inst:");
MODULE_INFO(linuxcnc, "pin:in-##:bit:pincount:in::None");
MODULE_INFO(linuxcnc, "pin:out:bit:None:out::None");
MODULE_INFO(linuxcnc, "instanceparam:maxpincount:int::5");
MODULE_INFO(linuxcnc, "instanceparam:pincount:int::2");
MODULE_INFO(linuxcnc, "instanceparam:iprefix:string::\"lut2\"");
MODULE_INFO(linuxcnc, "instanceparam:function_hex:int::0");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO



static int maxpincount = 5;
RTAPI_IP_INT(maxpincount, "Instance integer param 'maxpincount'");

static int pincount = 2;
RTAPI_IP_INT(pincount, "Instance integer param 'pincount'");

static char *iprefix = "lut2";
RTAPI_IP_STRING(iprefix, "Instance string param 'iprefix'");

static int function_hex = 0;
RTAPI_IP_INT(function_hex, "Instance integer param 'function_hex'");

struct inst_data {
    hal_bit_t *in[5];
    hal_bit_t *out;
};

static int maxpins = 5;
static void _(void *arg, long period);

static int instantiate(const char *name, const int argc, const char**argv);

static int delete(const char *name, void *inst, const int inst_size);

static int extra_inst_setup(struct inst_data* ip, const char *name, int argc, const char**argv);

#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int xthread_funct(const void *arg, const hal_funct_args_t *fa)
{
long period __attribute__((unused)) = fa_period(fa);

    // the following accessors are available here:
    // fa_period(fa) - formerly 'long period'
    // fa_thread_start_time(fa): _actual_ start time of thread invocation
    // fa_start_time(fa): _actual_ start time of function invocation
    // fa_thread_name(fa): name of the calling thread (char *)
    // fa_funct_name(fa): name of the this called function (char *)
    return 0;
}

static int export_halobjs(struct inst_data *ip, int owner_id, const char *name)
{
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int z;
    if(pincount > maxpins)
        z = maxpins;
    else
      z = pincount;
    for(j=0; j < z; j++) {
        r = hal_pin_bit_newf(HAL_IN, &(ip->in[j]), owner_id,
            "%s.in-%02d", name, j);
        if(r != 0) return r;
    }
    r = hal_pin_bit_newf(HAL_OUT, &(ip->out), owner_id,
            "%s.out", name, j);
    if(r != 0) return r;
    // exporting an extended thread function:
    hal_export_xfunct_args_t instxf = 
        {
        .type = FS_XTHREADFUNC,
        .funct.x = xthread_funct,
        .arg = "x-instance-data",
        .uses_fp = 0,
        .reentrant = 0,
        .owner_id = owner_id
        };

    instxf.uses_fp = 1;
    rtapi_snprintf(buf, sizeof(buf),"%s.xthread-funct", name);
    r = hal_export_xfunctf(&instxf, buf, name);
    if(r != 0)
        return r;
    return 0;
}

// constructor - init all HAL pins, params, funct etc here
static int instantiate(const char *name, const int argc, const char**argv)
{
struct inst_data *ip;
int r;
int k;

// allocate a named instance, and some HAL memory for the instance data
int inst_id = hal_inst_create(name, comp_id, sizeof(struct inst_data), (void **)&ip);

    if (inst_id < 0)
        return -1;

// here ip is guaranteed to point to a blob of HAL memory of size sizeof(struct inst_data).
    hal_print_msg(RTAPI_MSG_ERR,"%s inst=%s argc=%d",__FUNCTION__, name, argc);

// Debug print of params and values
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"maxpincount", maxpincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"pincount", pincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: string instance param: %s=%s",__FUNCTION__,"iprefix", iprefix);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"function_hex", function_hex);

// These pins - params - functs will be owned by the instance, and can be separately exited with delinst
    if(strlen(iprefix))
        r = export_halobjs(ip, inst_id, iprefix);
    else
        r = export_halobjs(ip, inst_id, name);
    // if the extra_inst_setup returns non zero will abort module creation
    k = extra_inst_setup(ip, name, argc, argv);

    if(k != 0)
        return k;

    if(r == 0)
        hal_print_msg(RTAPI_MSG_ERR,"%s - instance %s creation SUCCESSFUL",__FUNCTION__, name);
    else
        hal_print_msg(RTAPI_MSG_ERR,"%s - instance %s creation ABORTED",__FUNCTION__, name);
    return r;
}

int rtapi_app_main(void)
{
// Debug print of params and values
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"maxpincount", maxpincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"pincount", pincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: string instance param: %s=%s",__FUNCTION__,"iprefix", iprefix);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"function_hex", function_hex);
    // to use default destructor, use NULL instead of delete
    comp_id = hal_xinit(TYPE_RT, 0, 0, instantiate, delete, compname);
    if (comp_id < 0)
        return -1;

    // exporting an extended thread function:
    hal_export_xfunct_args_t xtf = 
        {
        .type = FS_XTHREADFUNC,
        .funct.x = xthread_funct,
        .arg = "x-instance-data",
        .uses_fp = 0,
        .reentrant = 0,
        .owner_id = comp_id
        };

    if (hal_export_xfunctf(&xtf,"%s.xthread-funct", compname))
        return -1;
    hal_ready(comp_id);

    return 0;
}

void rtapi_app_exit(void)
{
    hal_exit(comp_id);
}

// custom destructor - normally not needed
// pins, params, and functs are automatically deallocated regardless if a
// destructor is used or not (see below)
//
// some objects like vtables, rings, threads are not owned by a component
// interaction with such objects may require a custom destructor for
// cleanup actions
// NB: if a customer destructor is used, it is called
// - after the instance's functs have been removed from their respective threads
//   (so a thread funct call cannot interact with the destructor any more)
// - any pins and params of this instance are still intact when the destructor is
//   called, and they are automatically destroyed by the HAL library once the
//   destructor returns
static int delete(const char *name, void *inst, const int inst_size)
{

    hal_print_msg(RTAPI_MSG_ERR,"%s inst=%s size=%d %p\n", __FUNCTION__, name, inst_size, inst);
// Debug print of params and values
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"maxpincount", maxpincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"pincount", pincount);
    hal_print_msg(RTAPI_MSG_ERR,"%s: string instance param: %s=%s",__FUNCTION__,"iprefix", iprefix);
    hal_print_msg(RTAPI_MSG_ERR,"%s: int instance param: %s=%d",__FUNCTION__,"function_hex", function_hex);
    return 0;

}


struct inst_data *ip;


#undef FUNCTION
#define FUNCTION(name) static void name(void *arg, long period)
// if the extra_inst_setup returns non zero it will abort the module creation
#undef EXTRA_INST_SETUP
#define EXTRA_INST_SETUP() static int extra_inst_setup(struct inst_data *ip, const char *name, int argc, const char**argv)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#define in(i) (0+*(ip->in[i]))
#undef out
#define out (*ip->out)


#line 21 "lutn_inst.comp"


FUNCTION(_) 
{
int i;
ip = arg;
int shift = 0;

    for (i = 0; i < pincount; i++)
	if (in(i)) 
	    shift += (1 << i);

    out = (function_hex & (1 << shift)) != 0;
}

EXTRA_INST_SETUP()
{
int x;

    for(x = 0; x < argc; x++)
        hal_print_msg(RTAPI_MSG_ERR,"argv[%d] = %s", x, argv[x]);

    return 0;
}


