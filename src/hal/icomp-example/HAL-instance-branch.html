<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>What&#8217;s in the HAl instantiation branch</title>
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_what_s_in_the_hal_instantiation_branch">What&#8217;s in the HAl instantiation branch</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quick_summary">quick summary</h3>
<div class="ulist">

<ul>
<li>
<p>a backwards-compatible extension of the C HAL API and halcmd and to support
creation and deletion of components at run time</p>
</li>
<li>
<p>instcomp, an extended version of the comp component generator to
support this API</p>
</li>
<li>
<p>several migrated and new components</p>
</li>
<li>
<p>demo components for the new features</p>
</li>
</ul>
</div>

</div>
<div class="sect2">
<h3 id="_in_a_nutshell_what_can_i_do_with_it">in a nutshell - what can I do with it:</h3>
<div class="sect3">
<h4 id="_before_you_had_to_know_in_advance_how_many_copies_of_a_comp_you_need">before you had to know in advance how many copies of a comp you need:</h4>
<div class="literalblock">

<div class="content monospaced">
<pre>loadrt or2 count=2</pre>
</div>
</div>
<div class="paragraph">
<p>and that was it, you need one more - go back to the loadrt statement
and fix it, wherever that was</p>
</div>

</div>
<div class="sect3">
<h4 id="_after_create_instances_as_needed">after: create instances as needed</h4>
<div class="paragraph">
<p>(for the lutn component, see the man page for lut5 - it&#8217;s just a more
flexible version of lut5: variable number of pins, and instantiable -
note each instance can have different functions and number of pins):</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre># create 2 instances with 2 inputs each and the or function
# wherever needed
# syntax:
# newinst &lt;compname&gt; &lt;instance name&gt; &lt;per-instance parameters...&gt;
newinst lutn or2.0  inputs=2 function=0xe
newinst lutn or2.1  inputs=2 function=0xe</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre># the functs exported are named after the instance name
addf or2.0 &lt;threadname&gt;
addf or2.1 &lt;threadname&gt;</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre># NB: the 'loadrt lutn' command will happen automatically behind the
# scenes if not yet loaded
# and if you do not need it any more, destroy the instance</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>delinst or2.1</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre># poof, or2.1 is gone!</pre>
</div>
</div>
<div class="paragraph">
<p>or2.0 will continue to work as before.</p>
</div>

</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_api_change_thread_functions_are_now_int_not_void">API change: thread functions are now int, not void</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thread functions in instcomp-generated components <strong>must return 0</strong> for now; so far they were defined <em>void</em> and did not need to return a value.</p>
</div>
<div class="paragraph">
<p>This change has been made to enable future functionality. A return value is a way to signal the calling layer about success/failure, and there are good use case for this: in particular error signaling from the funct to the calling thread, and more mundane features generic statistics accumulation in the calling layer (per-thread). While this is currently not used, we decided to make the switch now because it is a large change anyway and this one is minor in relation.</p>
</div>
<div class="paragraph">
<p>All hal/i_components have been modified to adhere to this new convention.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_other_user_visible_changes">Other user-visible changes</h2>
<div class="sectionbody">
<div class="ulist">

<ul>
<li>
<p>there is a new named HAL object, called "instance", visible at the
halcmd ("show inst"), HAL C API, and HAL Cython API levels.</p>
</li>
<li>
<p>An instance is owned by a component, and has a name and a
size. Technically it is a blob of memory with a name, attached to a
component.</p>
</li>
<li>
<p>instances are relevant only for RT components. User components have
no use for the concept, and hence do not support it.</p>
</li>
<li>
<p>components, as well as instances may own pins, params and functs.</p>
</li>
<li>
<p>legacy components work unchanged as before and do not use instances.</p>
</li>
<li>
<p>newly written components, modified components (to use the instance
API) and components processed by Mick&#8217;s <em>instcomp</em> will support instances.</p>
</li>
<li>
<p>instances, as well as normal components, can have parameters.</p>
</li>
<li>
<p>instance and component parameters are distinct and cannot be mixed.</p>
</li>
<li>
<p>component parameters are applied at <em>loadrt &lt;compname&gt; &lt;params&gt;</em> as before.</p>
</li>
<li>
<p>to create an instance of a component, use the halcmd <em>newinst</em>
command (syntax: 'newinst &lt;compname&gt; &lt;unique instance name&gt; [any
instance paramters])</p>
</li>
<li>
<p>instance parameters apply at instantiation time, and only for that
particular instance, other than
component parameters, which apply at loadrt time.</p>
</li>
<li>
<p>to delete an instance of a component, use the halcmd <em>delinst</em>
command.</p>
</li>
<li>
<p>deleting an instance of a component will leave other instances untouched.</p>
</li>
<li>
<p>exiting a component will destroy all instances the component has,
including all pins, params and functs.</p>
</li>
<li>
<p>instance names MUST be unique.</p>
</li>
<li>
<p>Usage of pins, params, functs is no different between legacy
components and instances.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>legacy vs instantiable: cd field in show comp</p>
</div>
<div class="sect2">
<h3 id="_overview_of_changes_relevant_for_developers">Overview of changes relevant for developers</h3>
<div class="ulist">

<ul>
<li>
<p>Previously pins, params and functs were owned by components. The API
functions hence had a <em>int comp_id</em> parameter.</p>
</li>
<li>
<p>Now, pins, params and functs can be owned EITHER by a component, OR
by an instance (which in turn is always owned by a component).</p>
</li>
<li>
<p>All C API signatures have been changed to reflect this fact: where
formerly there was a <em>comp_id</em> parameter, it is now called an
<em>owner_id</em>, which can refer EITHER to a component or an instance.</p>
</li>
<li>
<p>A legacy component so far was initialized by hal_init("compname").</p>
</li>
<li>
<p>An instantiable component is initialized by the new hal_xinit() call,
which takes several parameters besides the name. To be instantiable, a
component MUST export a constructor function. It MAY export a
destructor function. A component which uses hal_xinit() but does not
export a constructor (NULL) behaves like a legacy component.</p>
</li>
<li>
<p>Coding an instantiable component ("icomp") must follow a certain protocol: see
the examples under src/hal/icomp-example to get the idea.</p>
</li>
<li>
<p>Once an icomp is instantiated with "newinst", its constructor
function will be called. The constructor is expected to check the
instance parameters, and once valide, create the named instance with
hal_inst_create().</p>
</li>
<li>
<p>The constructor is also responsible for initializing any pins,
params and functs which are owned by this instance. The pin+param
memory must lie in the blob of memory returned by hal_inst_create().</p>
</li>
<li>
<p>component parameters are declared as before with the RTAPI_MP_*
macros.</p>
</li>
<li>
<p>instance parameters are declare with the new RTAPI_IP_INT and
RTAPI_MP_STRING macros. Other types as well as arrays are currently not supported (and
unlikely to be needed).</p>
</li>
</ul>
</div>

</div>
<div class="sect2">
<h3 id="_instantiable_component_example">instantiable component example</h3>
<div class="paragraph">
<p>Some examples can be found in hal/icomp-example:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>lutn.c is an actually useful instantiable variant of lut5.c</p>
</li>
<li>
<p>icomp.c shows all variations of the instantiation API, not all of
which might be needed for every component</p>
</li>
</ul>
</div>

</div>
<div class="sect2">
<h3 id="_hal_userfunct_objects">HAL userfunct objects</h3>
<div class="paragraph">
<p>userfuncts are a similar to normal functs, but cannot be addf&#8217;d to a thread.</p>
</div>
<div class="paragraph">
<p>So what they are good for then? well, they can be called from userland via halcmd, or the C or Cython RTAPI API&#8217;s.</p>
</div>
<div class="paragraph">
<p>userfuncts are the basic feature on which the whole HAL instantiation API rests.
hal_lib is now a component and exports internal userfuncts (newinst and delinst)
to support the instantiation API.</p>
</div>
<div class="paragraph">
<p>ufdemo.c shows the API usage, as well as the extended thread API.</p>
</div>
<div class="paragraph">
<p>Show time!</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>$ realtime start
$ halcmd -f -k</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>halcmd: loadrt ufdemo</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>&lt;stdin&gt;:1: Realtime module 'ufdemo' loaded</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>halcmd: show comp</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>Loaded HAL Components:
    ID  Type Flags Inst Name                                      PID   State
 32770  RT            0 ufdemo                                    RT    ready, u1:0 u2:0
    71  User          0 halcmd1774                                1774  ready, u1:0 u2:0
    70  uHAL   i      0 hal_lib1774                               1774  ready, u1:0 u2:0
 32769  rHAL   i      0 hal_lib                                   0     ready, u1:0 u2:0</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>halcmd: show funct</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>Exported Functions:
  Comp   Inst CodeAddr  Arg       FP   Users Type    Name
 32769        b6e5fe6b  00000000  NO       0 user    delinst
 32769        b6e5fc13  00000000  NO       0 user    newinst
 32770        b753d83c  b753db7b  NO       0 user    ufdemo.demo-funct
 32770        b753d82d  b753db36  NO       0 thread  ufdemo.legacy-funct
 32770        b753d832  b753db5a  NO       0 xthread ufdemo.xthread-funct</pre>
</div>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>halcmd: call ufdemo.demo-funct foo bar baz
&lt;stdin&gt;:4: function 'ufdemo.demo-funct' returned 3
halcmd:</pre>
</div>
</div>
<div class="paragraph">
<p>relevant part of linuxcnc.log:</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt RTAPI: initing module HAL_ufdemo
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt RTAPI: module 'HAL_ufdemo' loaded, ID: 32770
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_xinit:246 HAL: legacy component 'ufdemo' id=32770 initialized
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_export_xfunctfv:70 HAL: exporting function 'ufdemo.legacy-funct' type 0
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_pin_new:121 HAL: creating pin 'ufdemo.legacy-funct.time'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_param_new:135 HAL: creating parameter 'ufdemo.legacy-funct.tmax'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_param_new:135 HAL: creating parameter  'ufdemo.legacy-funct.tmax-increased'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_export_xfunctfv:70 HAL: exporting function 'ufdemo.xthread-funct' type 1
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_pin_new:121 HAL: creating pin 'ufdemo.xthread-funct.time'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_param_new:135 HAL: creating parameter 'ufdemo.xthread-funct.tmax'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_param_new:135 HAL: creating parameter 'ufdemo.xthread-funct.tmax-increased'
Mar 12 21:25:28 nwheezy msgd:0: hal_lib:1768:rt hal_export_xfunctfv:70 HAL: exporting function 'ufdemo.demo-funct' type 2
Mar 12 21:25:28 nwheezy msgd:0: rtapi_app:1768:user ufdemo: loaded from ufdemo.so
Mar 12 21:25:53 nwheezy msgd:0: hal_lib:1768:rt ufdemo: userfunct 'ufdemo.demo-funct' called, arg='u-instance-data' argc=3
Mar 12 21:25:53 nwheezy msgd:0: hal_lib:1768:rt     argv[0] = "foo"
Mar 12 21:25:53 nwheezy msgd:0: hal_lib:1768:rt     argv[1] = "bar"
Mar 12 21:25:53 nwheezy msgd:0: hal_lib:1768:rt     argv[2] = "baz"</pre>
</div>
</div>

</div>
<div class="sect2">
<h3 id="_thread_api_extensions">thread API extensions</h3>
<div class="paragraph">
<p>This branch also contains work on a generalized thread API, which was
required for the userfunct feature to work.</p>
</div>
<div class="paragraph">
<p>The problems with the old API were:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>very limited exposure of runtime data (e.g. actual invocation times
are already computed in the calling code, but not exposed to thread
functions except the rather useless period setup parameter)</p>
</li>
<li>
<p>support for userfuncts was needed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For an overview of the new thread API, see src/hal/hal_priv.h .</p>
</div>
<div class="paragraph">
<p>Legacy code using the hal_export_funct API will continue to run unchanged.</p>
</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_easier_debugging_of_rt_msgd_haltalk_webtalk_nosighdlr">Easier Debugging of RT, msgd, haltalk, webtalk: NOSIGHDLR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Due to robust signal handling in these demons, it is hard to attach
these processes with gdb and debug. Also, on a crash the generated
core is sometimes not usable due to reasons which I do not
understand yet.</p>
</div>
<div class="paragraph">
<p>This branch introduces an environment variable
NOSIGHDLR which - if set - will disable signal trapping in these
demons.</p>
</div>
<div class="paragraph">
<p>This makes attaching with gdb -p &lt;process-id&gt;, as well as
detaching much simpler, and the processes do not exit on
detach.</p>
</div>
<div class="paragraph">
<p>The actual value of NOSIGHDLR is irrelevant.  There are
corresponding command line options <em>--nosighdlr/-G</em> which achieve
the same effect on a per-process basis.</p>
</div>
<div class="paragraph">
<p>Note this means default   signal handling, that is, the processes will exit without any
further log message, and maybe create a core.</p>
</div>
<div class="paragraph">
<p>To debug rtapi or msgd, it&#8217;s best to use the posix flavor, which will not complain
about RT violations due to the delays caused by debugging. it does
not matter for haltalk and webtalk because these are RT-unaware.</p>
</div>
<div class="paragraph">
<p>Initiating a debuggable RT session hence amounts to:</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>$ export DEBUG=5 FLAVOR=posix NOSIGHDLR=1
$ realtime start # or linuxcnc...</pre>
</div>
</div>
<div class="paragraph">
<p>To debug rtapi, use</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>$ sudo gdb -p `pidof rtapi:0`</pre>
</div>
</div>
<div class="paragraph">
<p>To debug msgd,  use</p>
</div>
<div class="literalblock">

<div class="content monospaced">
<pre>$ sudo gdb -p `pidof msgd:0`</pre>
</div>
</div>
<div class="paragraph">
<p>Debugging RT thread functions now works perfectly fine in userland flavors.</p>
</div>

</div>
</div>

</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-04-29 16:33:18 BST
</div>
</div>
</body>
</html>