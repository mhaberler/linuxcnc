= Remote Realtime Operations

Michael Haberler, 11/2013

:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}


== Purpose

This document gives a high-level overview of the goals and means of
remotely controlling and interacting with the HAL realtime environment.

== Problem statement

The traditional HAL environment has several deficiencies:

* there are is no API for remote interaction with scalar objects like pins, signals etc
* there is no generally usable API for injecting compound commands, and
receiving replies from arbitrary components
* the same holds for command/response interaction between RT components
* there's a duplicity of mechanism between special-purpose,
 compile-time defined status reporting (emcstatus) and interaction
 with HAL scalars

This results in several restrictions and undesirable consequences:

* realtime operations must execute on the same CPU as the UI, task and
  interpreter
* the lack of a command/response API to/from HAL components from
  non-realtime, as well as between components, has led to the single
  component which does special-purpose command/response messages -
  motion - has become the kitchen sink for 'everything command' and
  hence reached undesirable complexity
* the one-of-a-kind status reporting mechanism without a generalized
  transport API has made adaptation for new requirements painful

== Goal





== Means

== Concepts

=== Sampled state and observing events

What both the current code, and HALgroups do is: sample HAL




== Components

proto list

HALrcomp
HALgroup
HALrt - rtdemon
HALlog
HALrcmd

ticket pattern?
HAL API support
  rcomp
  group
new HAL objects
  rings
  groups
  rcomps

support stack: zeromq, protobuf
===



=== Remote Thread functions

In the traditional HAL model, a thread function is a piece of code
executing in the same address space as the HAL pins the component
defines. Thread functions typically read component input pins, provide some
processing function, and provide a result by setting output pins.

Remote Thread Functions are technically equivalent to the above,
however they are not required to reside in the same address space as
the HAL pins of the component.

With respect to timing remote thread functions are similar to userspace HAL
component code since due to network delays they cannot provide
realtime guarantuees.

=== Remote components

A Remote Component is a type of HAL components which enables remote
interaction with HAL at the pin level. A typical scenario would be a
user interface to HAL. In this model, a UI is a HAL component like any
other and its pins represent UI objects like LED's, buttons, sliders
etc.

Since HAL is based on a shared memory model, so far UI code was
assumed to run in the same address space as the realtime environment.

The component model remains unchanged with respect to component name, pin
names, type and direction.

Creating the component and its pins is decoupled from the
execution of thread function code. A remote component may be defined
at the halcmd level, or by using the HAL API. At this point, it's pins
may be linked to; however, the associated thread function is not
required to be active at pin link time.

A remote component is created by calling 'hal_init_mode(name,
TYPE_REMOTE)'. The creation of pins is identical to traditional
components. Calling 'hal_ready(compid)' will transition a remote
component to the state 'COMP_UNBOUND', whereas a local component will
enter the state 'COMP_READY'.

=== The proxy process

To be useful, a remote component requires a proxy process which
executes on the same host as the realtime environment, and
serves requests on behalf of one or several remote thread functions.

The proxy process interacts with the remote thread function by means
of the HALrcomp protocol.

A proxy process interacts with the remote HAL component by adopting a
dormant component by calling 'hal_acquire()' API method, and disowns
the component by calling 'hal_release()'. A non-zero process id in a
remote component descriptor indicates a proxy process has adopted the
component.

Only a component of 'TYPE_REMOTE' can be acquired and released.

A single proxy process may serve any number of remote components, and
may interact with any number of remote threads.

A remote component may be associated with several remote thread
functions at the same time. This supports the simultaneaous
interaction with several UI's, and may have limited applicability
outside the UI use case.

The overall interaction of HAL, the halserver proxy process and remote
threads like UI's looks like this:

[dia, halrcomps.dia, halrcomps.png, x240]
-------------------------------
-------------------------------

=== Bound and unbound state

Once a proxy process has acquired the component, a remote thread
function may interact with the proxy process to receive notification
of input pin changes, and set output pin values.

A remote component starts out in the unbound state, and enters the
bound state once a remote thread registers to receive pin change
notifications (states COMP_UNBOUND, COMP_BOUND).

=== Halcmd support for startup and shutdown

halcmd supports the following new commands:

. waitacquired <list of component names>
. waitbound <list of component names>
. waitunbound <list of component names>

'waitacquired' pauses halcmd execution until the named components
have been adopted by a proxy process by 'hal_acquire()'.

'waitbound' pauses halcmd execution until the associated components
exist and have entered the 'COMP_BOUND' state. 'bound' implies 'acquired'.

'waitunbound' pauses halcmd execution until the associated components
have entered the 'COMP_UNBOUND' state, or have exited.

=== Startup and Shutdown

Startup works as follows: halcmd loads components as usual, and starts
the proxy process which serves remote thread functions by a 'loadusr'
statement. Next, halcmd waits for all required remote components by
executing 'waitbound <compnames>'. This will pause the halcmd script
until all remote thread functions have registered with the proxy
process, and have defined remote components and their pins. After the
'waitbound' command completes, the halcmd script continues and pins
can be linked as usual.

Alternatively, remote components can be defined at the halcmd level by
means of the 'newcomp', 'newpin' and 'ready' commands. To wait for a
proxy process to adopt such components, execute 'waitacquired <compname>',

If the halcmd script should terminate once the last remote thread
function deregisters (for instance because the user interface was
terminated), the 'waitunbound <compname>' will wait for this
condition.

Thanks to zeroMQ semantics, the startup order of a remote UI and the
HAL realtime instance does not matter; a client will wait until the
matching server appears and can be connected to. This simplifies
startup considerably and also gets rid of the 'POSTGUI_HALFILE'
'feature' which was an unelegant workaround for startup sequencing issues.

== HALrcomp protocol overview

HALrcomp is the protocol used between a proxy process and the
(possibly remote) process defining the remote thread
function. HALrcomp also suppports the creation of remote components
and their pins, therefore the usage of 'newcomp', 'newpin' and 'ready'
to pre-define the remote component in halcmd is optional.

Once started, HALrcomp will verify all required pins exist and are of
proper type and direction. If a mismatch occurs, an error message
indicates the name of the offending HAL object.

HALrcomp is stateless except for changing the 'bound' state
of a component. This means that actually several remote thread
functions may by associated with a remote component: all thread
functions will receive pin change updates. If a thread function
changes a pin value, this change will eventually be reflected in all
connected parties.

HALrcomp is idempotent - stopping and restarting the process which
implements a remote thread function will result in an identical pin
binding.

HALrcomp has the following phases:

. the startup phase
. the interaction phase
. shutdown.

The following sequence diagram shows the three phases and associated
message flows:

["mscgen"]
---------------------------------------------------------------------
# HALrcomp message flow
msc {

  arcgradient = 4;

  a [label="Remote"],b [label="Halserver"], c [label="HAL"];

  a=>b [ label = "bind(comp=foo, pins=bar..)" ] ;
  b=>c [ label = "newcomp(foo)"];
  b=>c [ label = "newpin(bar) *"];
  b=>c [ label = "hal_ready(bar)"];
  b=>a [ label = "confirm(foo,pins=..)"];

  a=>b [ label = "subscribe(foo)" ] ;
  b=>c [ label = "status(foo) := bound"];
  b=>a [ label = "full pin status(foo)"];

  b=>c [ label = "periodic change detect(foo)"];
  c=>b [ label = "changed pin values(...)"];
  b=>a [ label = "incremental pin status(...)"];

  a=>b [ label = "setpin(foo := 4711)" ] ;
  b=>c [ label = "hal_setpin(foo,4711)"];
  b=>c [ label = "periodic change detect(foo)"];
  c=>b [ label = "changed pin values(foo = 4711)"];
  b=>a [ label = "incremental pin status(foo = 4711)"];

  a=>b [ label = "unsubscribe(foo)" ] ;
  b=>c [ label = "status(foo) := unbound"];

}
---------------------------------------------------------------------


During startup, a remote entity (for instance, a UI) connects to the
halserver proxy process and request creation of a remote component as
well as its pins, including type and direction.

If the remote component already exists, the pins, types and direction
are validated for a match, and missing or mis-typed pins are flagged
by an error message. If the remote component does not yet exist, the
component and its pins are created as specified in the inital request.

This phase concludes with a reply by halserver to the requesting
process by either declaring success, or indicating which names/types
etc were in error. The nature of this initial interaction is
request/reply (a remote procedure call or RPC).

Next, the remote thread function subscribes to a zeroMQ status publish socket
defined by halserver. Halserver detects this subscription event and
does the following:

. the component state is changed to 'bound'
. a full status report including all HAL pin values is published on
the status socket, causing all connected remotes to receive and
reflect the initial HAL pin values.
. periodic pin change detection commences: halserver starts scanning
for changes in the input HAL pins periodically and sends incremental status updates
on the publish socket. From now on, the remote(s) track all pin
changes, and for instance may reflect changes in widget display as needed.

Any other request by a remote connecting to halserver and requesting the same HAL
remote component will just result in a validation of the names, types
and directions. The status subscription again will result in a full
component pin status being published.

Halserver tracks the count of status subscriptions; a remote exiting
(e.g. UI shutdown) will cause a unsubscribe event, and halserver
decrements the subscriber count for the affected component. Once the
subscriber count reaches zero, the component transitions to 'unbound'
state; see also the related 'waitunbound' keyword in halcmd which may
optionally be used to shut down the realtime stack once the last UI is gone.

If a remote UI changes a pin, say by UI interaction (clicking a
button, changing a value in a input field etc), the corresponding
change event in the UI is used to send a 'set_pin' message to
halserver, requesting to reflect the change in the underlying HAL
pin(s). This pattern is a unidirectional message; the change in the
HAL pin value will cause the next update to reflect the new value.

== Implementation outline

The interaction is assumed to use zeroMQ as messaging stack, and
Google protobuf as message encoding method.

The socket types and options are:

. the halserver command submission socket is of type ROUTER.
. the halserver status update socket is of type XPUB, with the socket
option 'verbose' set so client subscribe/unsubscribe causes a message
reception event in halserver.
. status updates are sent with a topic name equal to the remote
component name.
. the remote command submission socket is of type DEALER.
. the remote command socket is assumed to have a unique identity set,
for instance 'gladvcp%d % (os.getpid())'.
. the remote status subscriber socket is of type XSUB.
. the remote is expected to subscribe to all remote component names it
is interested in receiving updates for.

== Example: Defining a remote component in halcmd

[source,{bash}]
---------------------------------------------------------------------
...
# 1. declare a remote component
newcomp gladevcp
newpin  gladevcp gladevcp.hal_button1 bit in eps=0.01 flags=4
newpin  gladevcp gladevcp.hal_label1  float out
ready   gladevcp

# 2. at this stage, the component and its pins exist
# and could be linked to signals; the gladvcp component is 'dormant'
# and 'unbound':
net toggle gladevcp.hal_button1
net range  gladevcp.hal_label1

# 3. the rcomp is still lacking a remote thread function.
# start the halserver proxy process, which will acquire any dormant
# remote components at this stage (in this case 'gladevcp')
loadusr -W halserver

# at this stage the gladevcp component will have the acquisition state 'aquired by
# the proxy process'. The UI is assumed to eventually start up and
# connect to halsever, after which the bind state of the component(s)
# served changes to 'bound'

# 4. now wait until the UI is connected to halserver
waitbound gladevcp

# commence realtime execution
start
---------------------------------------------------------------------

=== Remote Component defined via a remote UI process by HALrcomp

The HALrcomp protocol links a remote thread (typically a UI thread
function like gladevcp) to a HAL instance by interacting with a remote
component.

While in the above example the remote component was explicitly defined
by 'newcomp', 'newpin' and 'ready' commands, this is not required
because the component may just as well be defined by the remote
process bind phase. To do so, the bind message contains the component
attributes (name, pin names etc); halserver will create the remote
component if it does not yet exist. If the remote component already
exists, the component attributes in the bind message are validated
against that existing component, and an error message is generated on
missing or mismatched attributes.

This feature enables the implicit construction of a remote component
through startup of a UI which contains HAL widgets similar to
gladevcp: the HAL widget attributes are collected to construct the
bind message.


=== Impact on UI design and widget behavior

In previous versions of LinuxCNC, several UI's could connect to a
running instance and issue commands (run, auto, MDI etc), and the
resulting state would be reflected in all UI's by means of polling the
emcstatus structure.

This was different for HAL UI components, like gladevcp or pyvcp -
only a single instance of such a UI can exist since the UI is a HAL
component, which only may be defined once - starting the second UI
which tries to create an identically named HAL component would fail.

This changes through the introduction of HAL remote components: the
component and its pins are defined once only (by the first creator,
which might be halcmd or halserver acting on behalf of a remote
UI). Thereafter several UI's may connect to HAL and observe as
well as change HAL pins in such a component.

This has no impact on output pins (like say a LED component) - whoever
changes the underlying HAL pin, all connected parties will eventually
receive the value update for that pin, and the visual indication will
be identical in all UI's.

However, with input pins (for example a spinbutton to set a float or
integer HAL pin value), the following situation arises:

. Assume the spinbutton is changed in UI #1. The widget behavior is
such that the new value (e.g. by typing, or klicking up/down icons) is
reflected in the visual appearance of the widget, so UI #1 is fine.

. The HAL pin value is updated and the new value broadcast to all UI's
connected to the remote component.

. Assume UI #2 has an identical spinbutton to set and display this
value. To remain consistent, the widgets should display identical
values. However, as things stand, such output widgets are programmed
to react to UI actions only. Therefore, unless mitigated, UI#2 will
show a different value in the spinbutton than UI #1, which is
undesirable.

=== Required Change to UI widgets

Fortunately, the solution is relatively simple; it affects all
output widgets as follows:

An output widget must not only react to UI activity, it must also
react to HALrcomp value update messages sent by the proxy process.

This change is only necessary if several remote HAL UI's are to be run in
parallel. Since this is currently impossible, and likely not to be a
common scenario at least initially, this change can be rolled out
incrementally as needed.

It might make sense to enable this behavior by configuration values
after some experience has been gathered; conceptually  each output
widget now has two updaters - the local UI callback, and the status
update from Halserver. In principle, either one, or both could be used
to cause a widget update. The local case will be faster in UI
response, but not reflect say a HAL instance which has gone away; only
using remote status updates will always track the true HAL pin value
but likely be a bit slower than the local case. Using only remote or both update
sources will enable correct behavior if several UI's are used in parallel.
