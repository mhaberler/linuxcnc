= Remote HAL Components

:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}

//Name: rfc.machinekit.net/spec:rcomp

Editor: Michael Haberler <proto@mah.priv.at>

State: draft

== Purpose
 protocol (rcomp)
Remove the HAL limitation which requires all thread functions to execute
in the same address space.

== Overview


=== Remote Thread functions

In the traditional HAL model, a thread function is a piece of code
executing in the same address space as the HAL pins the component
defines. Thread functions typically read component input pins, provide some
processing function, and provide a result by setting output pins.

Remote Thread Functions are technically equivalent to the above,
however they are not required to reside in the same address space as the HAL pins
of the component.

Conceptually remote thread functions are similar to userspace HAL
component code since due to network delays they cannot provide
realtime guarantuees.

=== Remote components

A Remote Component is a type of HAL components which enables remote
interaction with HAL at the pin level. A typical scenario would be a
user interface to HAL. In this model, a UI is a HAL component like any
other and its pins represent UI objects like LED's, buttons, sliders
etc.

Since HAL is based on a shared memory model, so far UI code was
assumed to run in the same address space as the realtime environment.

The component model remains unchanged with respect to component name, pin
names, type and direction.

Creating the component and its pins is decoupled from the
execution of thread function code. A remote component may be defined
at the halcmd level, or by using the HAL API. At this point, it's pins
may be linked to; however, the associated thread function is not
required to be active at pin link time.

A remote component is created by calling 'hal_init_mode(name,
TYPE_REMOTE)'. The creation of pins is identical to traditional
components. Calling 'hal_ready(compid)' will transition a remote
component to the state 'COMP_UNBOUND', whereas a local component will
enter the state 'COMP_READY'.

=== The proxy process

To be useful, a remote component requires a proxy process which
executes within the address space of the realtime environment, and
serves requests on behalf of one or several remote thread functions.

The proxy process interacts with the remote thread function by means
of HAL rcomp protocol.

A proxy process interacts with the remote HAL component by adopting a
dormant component by calling 'hal_acquire()' API method, and disowns
the component by calling 'hal_release()'. A non-zero process id in a
remote component descriptor indicates a proxy process has adopted the
component.

Only a component of 'TYPE_REMOTE' can be acquired and released.

A single proxy process may serve any number of remote components, and
may interact with any number of remote threads.

A remote component may be associated with several remote thread
functions at the same time. This supports the simultaneaous
interaction with several UI's, and may have limited applicability
outside the UI use case.

=== Bound and unbound state

Once a proxy process has acquired the component, a remote thread
function may interact with the proxy process to receive notification
of input pin changes, and set output pin values.

A remote component starts out in the unbound state, and enters the
bound once a remote thread registers to receive pin change
notifications (states COMP_UNBOUND, COMP_BOUND).

=== Halcmd support for startup and shutdown

halcmd supports the following new commands:

. waitacquired <list of component names>
. waitbound <list of component names>
. waitunbound <list of component names>

'waitacquired' pauses halcmd execution until the named components
have been adopted by a proxy process by 'hal_acquire()'.

'waitbound' pauses halcmd execution until the associated components
exist and have entered the 'COMP_BOUND' state.

'waitunbound' pauses halcmd execution until the associated components
have entered the 'COMP_UNBOUND' state, or have exited,

=== Startup and Shutdown

Startup works as follows: halcmd loads components as usual, and starts
the proxy process which serves remote thread functions by a 'loadusr'
statement. Next, halcmd waits for all required remote components by
executing 'waitbound <compnames>'. This will pause the halcmd script
until all remote thread functions have registered with the proxy
process, and have defined remote components and their pins. After the
'waitbound' command completes, pins can be linked as usual.

Alternatively, remote components can be defined at the halcmd level by
means of the 'newcomp', 'newpin' and 'ready' commands. To wait for a
proxy process to adopt such components, execute 'waitacquired <compname>',

If the halcmd script should terminate once the last remote thread
function deregisters (for instance because the user interface was
terminated), the 'waitunbound <compname>' will wait for this condition.

=== Interaction model

===


== Purpose

rcomp supports the interaction of remote threads with
Remote components are HAL components which i

. support change tracking
. remote pin setting

== Properties

serially reusable.

== Implementation

Lorem Ipsum etc etc.

== Message Formats

Lorem Ipsum etc etc.

== States

This protocol is stateless.

== Protocol flows

sequence diagram 1..n.

== Error detection

scenario 1.
scenario 2.
scenario 3.
Shutdown of party 1.
Shutdown of party 2.





:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}

== Purpose

To get rid of NML, we need to replace two functions of the NML/RCS
stack:

- the transport function (shared memory and TCP)
- the message serialisation/deserialisation function

It has turned out that replacing the transport first, and
serialisation second is a preferrable route as it allows coexistence
and regression testing.

We also need to replace the interaction patterns currently in use:


=== Replacing the NML/RCS transport: the interaction patterns

The basic functions currently in use are:

. command submission
. waiting for reception acknowledgement OR:
. optionally waiting for command execution completion
. status observation: basically peeking at the EMC_STAT structure.
. error message distribution

4 and 5 can be easily mapped onto the ZMQ PUB/SUB pattern, 1-3
are a bit more involved:

=== ZeroMQ flows in the task/gui interactions



The Remote HALcomp Protocol

Purpose

watch component input pins
update comp output pins
support several observers/updaters
create/bind step shall be idempotent
  - first bind creates hal rcomp
  - bind of an existing hal rcomp only verifies pins (names, types,
  direction)
stateless, idempotent, multiple binds possible
proxy process does acquire/release


updates by proxy process: via XPUB/verbose socket
  periodically detect for changes
  on change transmit changed pins
  on new subscriber transmit full update

bind phase:

  observer: MT_HALCOMP_BIND {compspec}
  compspec = name ninst pinlist
  pinlist = pinspec *
  pinspec = name type dir
  name = "for.%d.mat" | "format"

  wait for reply, fail on timeout
  reply:
    MT_HALCOMP_BIND_REJECT compname all mismatched pins errormsg
    can happen on bind of existing comp only
  or
    MT_HALCOMP_BIND_CONFIRM compname all matched pins
    happens on creation or re-bind of




open questions:

how to handle multiple instances? nothing special except ninst and %d
in names
one update channel per instance?
what is with observer going away? solution: count subscribers; count=0
-> unbind()

bind message: has create flag - if false, bind only, no create = test
for existence

server process level: publish all compnames on XPUB socket? HAL
discovery proto?

HAL shutdown detect --> publish on status XPUB
