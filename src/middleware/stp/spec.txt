TODO:
stp_stats(tracker)
--> log_info

merge with halupdate? what was that again... haltracker. done.

check_updates ;  time->startup arg - by thread?
API need: timed wait for initial update!


----------------



STP Terminology:

tracker:: monitors

service::
- a protocol (zmq sockets, update)
- serialisation API
- version number

source:: a service may contain several named sources.

group:: named source within a service.

monitored variable:: a single scalar subject to update as monitoring
on the originating side detects changes.

-------
pollitems are per source

data struct needs:

1. backlink to tracker from source? to get at context, Container - DONE

fast:
	topic -> group of source, accessed from source, map in source;
		unique within a source
	handle -> var (unique), map in group

slow:
	name -> var; map in group
	tracker -> sources


-------



todo:

tracker error condition:
    1. an error if not all groups had a full update
    2. after initial full update, not all of the vars have a
    handle/initial value!
    --> check after inital update!

    keep flag: set on subscribe, clear on initial update 'full_update_pending'
    keep group update count, var update count?
    dump updates - group varname value updatecount ? pass FD


triggered reports (end of cycle) as alternative to thread-based)
	  in this case the thread only handles
	  subscribe/unsubscribe/initial full updates
	  --- lock needed so sub/unsub/full report
	  -- or trigger/wait/nowait for complete?

once thread is started, no more group/member adds!!

support ephemeral ports
integrate  UDP discovery example


server-side api
client-side api

unifiy hal and non-hal generation?
	  probably not worth it

unify with halrcomp update msg
      yess!

how to track strings/blobs
    change detect?
    explicit set_changed()?!

return handle from tracked!

----
C api: sm_/st_ ?



    setup-time declaration: Any entity may choose to export a set of typed variables assembled into groups as defined at setup time (this applies to observing HAL signals in particular, but also programs in scripting languages; only with compiled language code like C++ the set of exported groups and members likely will be static).

    introspection support: observers shall be able to inspect groups, their member variables and types and subscribe to those they declare interest in.

    selective subscription: observers shall receive updates only for groups they are interested in.

    type support: STP shall support the HAL basic types (bool, signed, unsigned, double) as well as strings and byte blobs.

    per-group reporting intervals: it shall be possible to define reporting intervals on a per-group basis to support varying update rate needs,

    idempotent behavior: an observer which exits and restarts will see the identical observed state all other observers see post initial update.

    update atomicity: an observer may rely on all variables in a group to reflect their last observed value once a group-update complete callback is executed.



# ----- talker side api:

mvar_t *m0 = sm_float(name, float *)
mvar_t *m1 = sm_s32(name, s32 *)
mvar_t *m2 = sm_32(name, u32 *)
mvar_t *m3 = sm_bool(name, bool *)
mvar_t *m4 = sm_string(name, char *)
mvar_t *m5 = sm_blob(name, void *, size_t)

sm_mark_changed(mvar_t *);

group_t *mgroup =  sm_group_new(name, interval, callback, void *data)

sm_group_add(group, m0);
sm_group_add(group, m1);
sm_group_add(group, m2);
sm_group_add(group, m3);

 // creates instance struct,socket, context, bind, sockopt
talker_t *talker = sm_talker_new(zmquri);

sm_talker_add(talker, mgroup);  // adds to groups list
sm_talker_run(talker);   // run poller, timer, subscribe_cb
sm_talker_stop(talker);  // send exit task command, wait finished?


#----- consumer side api

tracker_t *tr =    st_tracker()
tsource_t *tsrc =  st_tracker_addsource(tracker_t, zmquri)
tgroup_t *tgroup = st_tracker_subscribe(tsrc, groupname)

tracked_var_t *m = st_float(tgroup, name, float *, callback, void *data)
tracked_var_t *m = st_s32(tgroup, name, s32 *, callback, void *data)
tracked_var_t *m = st_u32(tgroup, name, u32 *, callback, void *data)

st_group_addvar(tgroup, callback, void *data);

st_group_addcb(tgroup, callback, void *data);

st_tracker_start(tr);
st_tracker_stop(tr);
rc = st_tracker_check(talker); // that all groups/vars had a full update

-----

concepts:
	reporter
		manages groups
		manages subscriptions

		methods:
			talks STP
			addgroup/delgroup
			newreport, addmembertoreport

	group
		name
		interval
		(reporting options)
		set of members
		methods: newgroup, addmember, reportfull, reportchanged

	member
		name
		type
		direction
		epsilon
		(options)
		handle
		methods:


abstract base class
	 StpReport
	 StpGroup
	 StpMember

derived classes:
	HalStpReport
	HalStpGroup
	HalStpMember
