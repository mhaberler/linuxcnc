// use a self-describing format as suggested in protobuf docs
// and on the mailing list

package pb;


import "nanopb.proto";
import "types.proto";
import "object.proto";
import "log.proto";
import "motcmds.proto";
import "halupdate.proto";
import "test.proto";
import "task.proto";
import "canon.proto";
import "rtapicommand.proto";
import "rtapi_message.proto";

message Container {

    // see https://developers.google.com/protocol-buffers/docs/techniques#union
    // for the principles behind this encoding

    required ContainerType type = 1;

    // protobuf-encoded submessages
    // tags with values in the range 1 through 15 take one byte to encode
    // so place the frequently used compound messages here

    optional MotionCommand motcmd         = 3;  // new style
    optional MotionStatus  motstat        = 4;  // new style
    optional bytes         legacy_motcmd  = 5;  // emcmot_command_t wrapped in PB
    optional bytes         legacy_motstat = 6;  // emcmot_status_t wrapped in PB
    optional bytes         wou            = 7;  // Arais Wishbone-over-USB
    optional HalUpdate     hal_update     = 8;  // halupdate protocol
    optional RTAPI_Message rtapi_message  = 9;
    optional TaskReply     task_reply     = 10;
    optional TicketUpdate  ticket_update  = 11;
    optional LogMessage    log_message    = 12;
    // simplified argument list for hal_rcomp/stp  updates
    repeated Signal                signal = 13;  //  [(nanopb).max_count = 20];

    // tags in the range 16 through 2047 take two bytes.
    // various blobs and less frequently used messages

    optional bytes         syslog         = 18;  // RFC5424 syslog(3) encoding
    optional bytes         legacy_nml     = 19;  // legacy NML container
    optional bytes       legacy_motconfig = 20;  // emcmot_config_t wrapped in PB

    // timestamps: as per struct timespec
    // obtain with clock_gettime(CLOCK_REALTIME, &spec);
    optional int32              tv_sec    = 21;  // can be used with ctime(3)
    optional int32              tv_nsec   = 22;

    // this is for messages going over pub/sub streams and wind up in JSON frames
    // duplicating the topic here allows us to drop the topic frame
    optional string                 topic = 23;

    // this is an or of bits in ReplyType:
    optional int32                   rsvp = 30;  // if/how to answer
    optional ContainerType    in_reply_to = 33;

    optional RCS_STATUS       rcs_status =  35;
    optional StatusType            status = 40;

    optional int32                 serial = 45;  // legacy command serials
    optional int32           reply_serial = 50;  // echoes the legacy command serial

    optional int32                 ticket = 55;  // command serials
    optional int32           reply_ticket = 60;  // echoes the legacy command serial

    // Credit based flow control: http://hintjens.com/blog:15
    optional int32               sequence = 62;  // running count used by producero
    optional int32                 credit = 65;  // updated by consumer

    // legacy line number as conveyed on interplist
    // to be replaced by source context
    optional int32            line_number = 66;

    // used with MT_MESSAGEBUS_NO_DESTINATION
    optional string                  name = 67;  // faulty messagebus destination
    repeated string                  note = 68;  // easy tack-on for debugging
    optional int32                retcode = 69;  // all purpose integer return code

    // generalized error descriptor
    optional AnError                error = 70;

    // uuid helps distinguish server instances
    optional bytes                  uuid  = 72;

    optional bool                   trace = 75;  // log from intermediaries

    optional int32               instance = 77;  // RTAPI instance if nonzero

    // where is this coming from:
    optional Originator            origin = 80;

    // generalized polymorphic argument list
    repeated Object                arg   = 85;  //  [(nanopb).max_count = 20];

    optional RTAPICommand           rtapicmd = 86;

   //  // string argv-type vector; used in MT_RTAPI_APP_* and possibly others
   //  repeated string                 argv =  86;  //  [(nanopb).max_count = 20];

   // // MT_RTAPI_APP_LOG_*, loglevels
   //  optional int32              loglevel = 87;

   //  // MT_RTAPI_APP_REPLY, possibly with 'note' tacked on:
   //  optional int32               retcode = 88;

   //  // used in MT_RTAPI_APP_LOADRT
   //  optional string              modname = 89;

   //  // used in MT_RTAPI_APP_LOADRT
   //  optional int32              instance = 90;

    // remote comp description for MT_HALCOMP_CREATE: [comp, pins*]
    optional Component              comp = 93;

    // simplified argument list for HAL UI remote comps
    // used in MT_HALCOMP_CREATE, MT_HALCOMP_SET_PINS, MT_HALCOMP_PIN_CHANGE
    repeated Pin                  pin = 95;


    // miscellanous
    optional string        ascii          = 100;
    optional bytes         unicode        = 101;
    optional string        gcode          = 102;
    optional string        python         = 103;
    optional bytes         pickle         = 104;
    optional string        tcl            = 105;
    optional string        xml            = 106;
    optional string        json           = 107;
    optional bytes         jpeg           = 108;
    optional bytes         png            = 109;
    optional bytes         tiff           = 110;
    optional bytes         postscript     = 111;
    optional bytes         svg            = 112;

    // a reply may carry several service announcements:
    repeated ServiceAnnouncement  service_announcement = 116;


    // infrequent compound messages

    //  messages of the halupdate protocol:
    optional Offer                  offer = 150;
    optional ConfirmOffer         confirm = 155;
    optional DisplayMessage    displaymsg = 160;
    optional Shutdown            shutdown = 165;
    optional ConfirmShutdown  confirm_shutdown = 170;


    // taskplan (interpreter command) messages
    optional TaskPlanExecute     tpexecute     = 200;
    optional TaskPlanBlockDelete tpblockdelete  = 201;
    optional TaskPlanOptionalStop tpoptionalstop  = 202;
    optional TaskPlanOpen         tpopen     = 203;

    // interpreter reply
    optional TaskPlanReply taskplan_reply       = 210;

    // canon messages
    optional Emc_Traj_Set_G5x                 traj_set_g5x = 300;
    optional Emc_Traj_Set_G92                 traj_set_g92 = 310;
    optional Emc_Traj_Set_Rotation       traj_set_rotation = 320;
    optional Emc_Traj_Linear_Move         traj_linear_move = 330;
    optional Emc_Traj_Probe                     traj_probe = 340;
    optional Emc_Traj_Circular_Move     traj_circular_move = 350;
    optional Emc_Traj_Rigid_Tap             traj_rigid_tap = 360;
    optional Emc_Traj_Set_Term_Cond     traj_set_term_cond = 370;
    optional Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
    optional Emc_Traj_Delay                     traj_delay = 390;
    optional Emc_Spindle_On                     spindle_on = 400;
    optional Emc_Spindle_Speed               spindle_speed = 410;
    optional Emc_Spindle_Orient             spindle_orient = 420;
    optional Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
    optional Emc_Tool_Set_Offset tool_set_offet = 440;
    optional Emc_Traj_Set_Offset traj_set_offset = 450;
    optional Emc_Tool_Prepare tool_prepare = 460;
    optional Emc_Tool_Set_Number tool_set_number = 470;
    optional Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
    optional Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
    optional Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
    optional Emc_Motion_Adaptive motion_adaptive = 510;
    optional Emc_Operator_Display operator_display = 520;
    optional Emc_Operator_Text operator_text = 530;
    optional Emc_Operator_Error operator_error = 540;
    optional Emc_Motion_Set_Dout motion_set_dout = 550;
    optional Emc_Motion_Set_Aout motion_set_aout = 560;
    optional Emc_Aux_Input_Wait aux_input_wait = 570;
    optional Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
    optional Emc_Io_Plugin_Call io_plugin_call = 590;

    // less commonly used types

    // firmware types. Add as needed
    optional bytes         pru_firmware   = 2048;

    // Mesanet firmware types: 3000 - 4000
    optional bytes         mesa_5i20_firmware   = 3000;

    // test message range: 5000-5100 - never used by core code
    optional Test1         test1          = 5001;
    optional Test2         test2          = 5002;
    optional Test3         test3          = 5003;


    // NB: do not use the numbers 19000 though 19999
    // they are reserved for the Protocol Buffers implementation
    // protoc will complain
}
